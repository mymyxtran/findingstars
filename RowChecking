module RowChecking(
		setMidPix, 
		pLoad, 
		xIn, 
		yIn, 
		countxREN, 
		countYEn, 
		clk, 
		resetn, 
		mostR, 
		mostB, 
		mostRightEN, 
		mostBottomEN, 
		rightEdgeReached,
		doneCalcMidPix,
		doneCheck);  
/* This module's purpose is to find the mostRight, mostbottom of the star. 
Problem encountered: when looking for the bottom most pixel, the 2 most bottom points of the star
are hard to identify. This code identifies the right most x value, but not the mostBottom. */

		parameter xSz = 3;
		parameter ySz = 3;
		parameter addrSz = 6;
		parameter colSz = 3;

		//set the threshold for pixel value
		localparam THRESHOLD = 0;

		input clk, resetn;

		// Enable signals used in registers and combinational logic for counters and computing mostR, mostB
		input countxREn; 	// used to enable the right x counter 
		input countYEn; //enable for counter y
		input pLoad; 
		input calcMidPix; // This only occurs once. After the rightmost traversal, calculate the midpix value.
		input setMidPix; // This only occurs once. After the calculation of the midpix value.

		input starFound;//if star is found this counter begins
		input mostRightEN; // start this always block when signal is high
		input mostBottomEN; // do comparison of previous mostBottomValue with current mostBottomValue

		output doneCheck; //   check is completed
		output doneCalcMidPix;
		output rightEdgeReached;

		//input x and y coor to load counters if required
		input[xSz-1:0] xIn;
		input[ySz-1:0] yIn;

		output reg [xSz-1:0] mostR;
		output reg [ySz-1:0] mostB; 

		reg [xSz-1:0] midPix; 

		reg[xSz-1:0] xCount;//output wires for counters
		reg[ySz-1:0] yCount;

		wire[addrSz-1:0] addressOut;//address wire from translator

		wire[colSz-1:0] pixVal; 
	
	always@(posedge clk) begin
		always@(posedge clk) begin
		if(!resetn)
			originalX <= 0;
		else if(pLoad) // Initally, after the star is found, load in the y coordinate value.
			originalX <= xIn;

	end
	
	//instantiate the x counter
	always@(posedge clk) begin
		if(!resetn)
			xCount <= 0;
		else if(pLoad) // Initally, after the star is found, load in the x coordinate value.
			xCount <= xIn;
		else if(countXEn)
			xCount <= xCount + midPix + 1;		
		
	end
	
	//instantiate the y counter
	always@(posedge clk) begin
		if(!resetn)
			yCount <= 0;
		else if(pLoad) // Initally, after the star is found, load in the y coordinate value.
			yCount <= yIn;
		else if(countYEn) 
			yCount <= yCount + 1;	
	end
	
	// need to add code for what happens after you reach mostR... x count must reset to some value (the middle pixel of the pic)

	// use trans0 and ram0 for access to xCount pixval
	//instantiate address translator // input your x,y coordinates // output is the address you want to access
	address_translator trans0(.x(xCount), .y(yCount), .mem_address(addressOut));

	//instantiate mem block
	ram36x3 ram0(.address(addressOut),.q(pixVal), .clock(clk), .wren(1'b0)); // got rid of wrEN signal bc this memory is read only.. but can/should i do this? 

  // check for a black pixel (edge is reached) after incrementing the xCount by 1
  assign rightEdgeReached = (pixVal < THRESHOLD);
  
  // not done this, will continue later
  always@(*) 
  begin
		if(mostRightEN == 1'b1)  // If at the checkPix state, enable mostRightEN to do comparison. If the mostR is smaller than the current x-value, then overwrite the current value of mostR.
			begin
				if(mostR < xCount)
					mostR = xCount;
				else
					mostR = mostR;
			end
		if(mostBottomEN == 1'b1) // If at the checkPix state, enable mostBottomEN to do comparison.
			begin
				if(mostB < yCount)
					mostB = yCount;
				else
				mostB = mostB;
			end	
			
		if(yCount == 0'b1) // Calculate the value of the middle pixel. This occurs once. midPix will be used as a starting point for looking for mostR.
			begin 
				midPix = (mostR + xCount) >> 1; // might need to change this
			end
   end
   
endmodule

module controlRowChecker();

always@(*)
begin: state_table
	case(current_state)
		RESET: next_state = LoadIn;
		LoadIn: next_state = INCREMENT_X;
		INCREMENT_X: next_state = edgeReached;
		edgeReached: next_state = rightEdgeReached? CHECK_PIX : INCREMENT_X;
		CHECK_PIX: begin
				if(Finish
		
		
	
	
	endcase

end

 // Note: if you reach the edge, then increment y and go back to your ref x value and the space is black, you are done
