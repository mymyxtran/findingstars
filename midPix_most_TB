module midPix_most_TB(
		pLoad, 
		xIn, 
		yIn, 
		countXEn, 
		countYEn, 
		clk, 
		resetn, 
		mostBottom,
		mostTop,
		midPix,
		rightEdgeReached,
		bottomEdgeReached);  

		parameter xSz = 3;
		parameter ySz = 3;
		parameter addrSz = 6;
		parameter colSz = 3;

		//set the threshold for pixel value
		localparam THRESHOLD = 0;

		input clk, resetn;

		// Enable signals used in registers and combinational logic for counters and computing mostR, mostB
		input countXEn; 	// used to enable the right x counter 
		input countYEn; //enable for counter y
		input pLoad; 

		input starFound;//if star is found this counter begins

		output rightEdgeReached;
		output bottomEdgeReached;

		//input x and y coor to load counters if required
		input[xSz-1:0] xIn;
		input[ySz-1:0] yIn;

		output [ySz-1:0] mostBottom; 
		output [ySz-1:0] mostTop; 
		output [xSz-1:0] midPix; // Will be used to calculate right and left most. 

		reg[xSz-1:0] xCount;//output wires for counters
		reg[ySz-1:0] yCount;
	        reg[xSz-1:0] xOriginal; // store inital x value to calculate midpix
		reg[xSz-1:0] yOriginal; // store inital y value to have top most

		wire[addrSz-1:0] addressOut;//address wire from translator

		wire[colSz-1:0] pixVal; 
	
	//instantiate the x counter
	always@(posedge clk) begin
		if(!resetn) 
			begin
			xCount <= 0;
			end
		else if(pLoad) 
			begin // Initally, after the star is found, load in the x coordinate value.
			xCount <= xIn;	
			xOriginal <= xIn;
			end
		else if(countXEn)
			xCount <= xCount + 1;		
		
	end
	
	// This value will not change once we start looking for the most bottom, since xCount and xOriginal do not change.
	assign midPix = (xCount + xOriginal) >> 1; // using the right most value and the orignal calculate the midpix
	
	//instantiate the y counter
	always@(posedge clk) begin
		if(!resetn)
			yCount <= 0;
		else if(pLoad) // Initally, after the star is found, load in the y coordinate value.
			yCount <= yIn;
			yOriginal <= yIn;
		else if(countYEn)
			yCount <= yCount + 1;	
	end
	
	// use trans0 and ram0 for access to xCount pixval
	//instantiate address translator // input your x,y coordinates // output is the address you want to access
	address_translator trans0(.x(xCount), .y(yCount), .mem_address(addressOut));

	//instantiate mem block
	ram36x3 ram0(.address(addressOut),.q(pixVal), .clock(clk), .wren(1'b0)); // got rid of wrEN signal bc this memory is read only.. but can/should i do this? 

	// Check for a black pixel (edge is reached) after incrementing the xCount by 1	.
	assign rightEdgeReached = (pixVal < THRESHOLD); // This signal indicates when to start mostBottom traversal.
	
	// This signal stop datapath, since all calculations are complete.
	assign bottomEdgeREACHED = (pixVal < THRESHOLD) && (countYEn == 1'b1);

	// Once bottomEdge is found, mostBottom will have the highest yvalue coordinate stored, yCount.
	assign mostBottom = yCount;
	
	// Output this for easier input into next fsm.
	assign mostTop = yOriginal;


module controlRowChecker();

always@(*)
begin: state_table
	
	case(current_state)
		RESET: next_state = LoadIn;
		LoadIn: next_state = INCREMENT_X;
		INCREMENT_X: next_state = rightEdgeReached? INCREMENT_Y : INCREMENT_X; // begin search for most bottom
		INCREMENT_Y: next_state = bottomEdgeReached? DONESEARCH : INCREMENT_Y;
		DEFAULT: next_state = RESET;
	
	endcase

end

 // Note: if you reach the edge, then increment y and go back to your ref x value and the space is black, you are done
